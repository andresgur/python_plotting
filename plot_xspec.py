{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "def read_comp_diskbb(comp_file):\n",
    "    data = np.genfromtxt(comp_file, delimiter='\\t', names=True, dtype=(\"U23\", \"U13\", \"U14\", \"U11\", \n",
    "                                                                       \"<f8\", \"<f8\", \"<f8\", \n",
    "                                                                       \"<f8\", \"<f8\", \"<f8\",\n",
    "                                                                      \"<f8\", \"<f8\", \"<f8\"),\n",
    "                        converters={10: logtoflux, 11: logtoflux_bounds, 12: logtoflux_bounds})\n",
    "\n",
    "    if len(np.atleast_1d(data))>1:\n",
    "        data.sort(order='epoch')\n",
    "    return data\n",
    "\n",
    "\n",
    "def read_pulsations_file(file):\n",
    "    data = np.genfromtxt(file, delimiter='\\t', names=True, dtype=(\"U23\", \"U13\", \"U14\", \"U11\", \n",
    "                                                                       \"i8\", \"<f8\", \"<f8\"))\n",
    "    if len(np.atleast_1d(data))>1:\n",
    "        data.sort(order='epoch')\n",
    "    return data\n",
    "\n",
    "def read_tbabs(comp_file):\n",
    "    data = np.genfromtxt(comp_file, delimiter='\\t', names=True, dtype=(\"U23\", \"U11\", \"U14\", \"U10\", \n",
    "                                                                       \"<f8\", \"<f8\", \"<f8\"), \n",
    "                         converters={5:linked_to_errors, 6:linked_to_errors})\n",
    "    if len(np.atleast_1d(data))>1:\n",
    "        data.sort(order='epoch')\n",
    "    return data\n",
    "\n",
    "def linked_to_errors(x):\n",
    "    if float(x)==-3:\n",
    "        return 0.0000001\n",
    "    else:\n",
    "        return x\n",
    "\n",
    "\n",
    "def read_comp_cutoffpl(comp_file):\n",
    "    data = np.genfromtxt(comp_file, delimiter='\\t', names=True, \n",
    "                         dtype=(\"U23\", \"U13\", \"U7\", \"U14\", \"<f8\", \"<f8\", \"<f8\", \n",
    "                                \"<f8\", \"<f8\", \"<f8\",\"<f8\", \"<f8\", \"<f8\",\n",
    "                               \"<f8\", \"<f8\", \"<f8\"), \n",
    "                         converters={13: logtoflux, 14: logtoflux_bounds, \n",
    "                                     15: logtoflux_bounds})\n",
    "    data.sort(order='epoch')\n",
    "    return data\n",
    "\n",
    "def read_comp_compTT(comp_file):\n",
    "    data = np.genfromtxt(comp_file, delimiter='\\t', names=True, \n",
    "                         dtype=(\"U23\", \"U13\", \"U7\", \"U14\", \"<f8\", \"<f8\", \"<f8\", \n",
    "                          \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\",\n",
    "                          \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\",\"<f8\", \"<f8\", \"<f8\"), \n",
    "                         converters={22: logtoflux, 23: logtoflux_bounds, \n",
    "                                     24: logtoflux_bounds})\n",
    "    data.sort(order='epoch')\n",
    "    return data\n",
    "\n",
    "def tojd (x):\n",
    "    return Time(x).jd\n",
    "     \n",
    "\n",
    "\n",
    "def logtoflux_bounds(x):\n",
    "    # keep upper and lower bounds to 0\n",
    "    if float(x)==0:\n",
    "        print(\"Flux bound found\")\n",
    "        return 0\n",
    "    else:\n",
    "        return m.pow(10,float(x))\n",
    "    \n",
    "def logtoflux(x):\n",
    "    return m.pow(10,float(x))\n",
    "\n",
    "def read_flux_data(flux_file):\n",
    "    data = np.genfromtxt(flux_file, delimiter='\\t', names=True, \n",
    "                         dtype=(\"U23\", \"U13\", \"U7\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \n",
    "                                \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\", \"<f8\"), missing_values='Error',\n",
    "                         converters={3: tojd, 4: logtoflux, 5: logtoflux_bounds, 6: logtoflux_bounds, \n",
    "                                    7: logtoflux, 8: logtoflux_bounds, \n",
    "                                   9: logtoflux_bounds, 10: logtoflux, 11: logtoflux_bounds, 12: logtoflux_bounds,\n",
    "                                    13: logtoflux, 14: logtoflux_bounds, 15: logtoflux_bounds}, filling_values=0)\n",
    "    data.sort(order='epoch')\n",
    "    return data\n",
    "\n",
    "def remove_legend_repetitions(ax):\n",
    "    \"\"\"Removes any repetead entries in the legend. Adds the legend to the plot too.\n",
    "    Parameters\n",
    "    ----------\n",
    "    ax : The axis were the repeated entries are to be removed. \"\"\"\n",
    "    handles, labels = ax.get_legend_handles_labels()\n",
    "    by_label = OrderedDict(zip(labels, handles))\n",
    "    ax.legend(by_label.values(), by_label.keys(), loc='best', prop={'size': 20})\n",
    "\n",
    "def bounds_to_errors(values, lowerbounds, upperbounds):\n",
    "    ''' Compute errors given the lower and upper bounds of a an array of values.\n",
    "    Parameters:\n",
    "    -----------\n",
    "    value : the central values given by the fit\n",
    "    lowerbound : its lower bounds\n",
    "    upperbound : its upper bounds'''\n",
    "\n",
    "    lower_errors = values - lowerbounds\n",
    "    upper_errors = upperbounds - values\n",
    "    \n",
    "    for value, lowerbound, upperbound in zip(values, lowerbounds, upperbounds):\n",
    "        \n",
    "        if upperbound<value and upperbound!=0:\n",
    "            print(\"Warning upperbound is lower than value!!! %.5f < %.5f\" % (upperbound, value))\n",
    "        if lowerbound>value and lowerbound!=0:\n",
    "            print(\"Warning lowerbound is higher than value!!! %.5f > %.5f\" % (lowerbound, value))\n",
    "            \n",
    "    \n",
    "    lolims = np.zeros(lower_errors.shape)\n",
    "    # lower bound\n",
    "    lolims[np.where(lowerbounds==0)] = 1\n",
    "    values[np.where(lowerbounds==0)] = upperbounds[np.where(lowerbounds==0)]\n",
    "    upper_errors[np.where(lowerbounds==0)] = values[np.where(lowerbounds==0)] / 10\n",
    "    # upper bound\n",
    "    uplims = np.zeros(lower_errors.shape)\n",
    "    uplims[np.where(upperbounds==0)] = 1\n",
    "    values[np.where(upperbounds==0)] = lowerbounds[np.where(upperbounds==0)]\n",
    "    lower_errors[np.where(upperbounds==0)] = values[np.where(upperbounds==0)] / 10\n",
    "    return lower_errors, upper_errors, lolims, uplims\n",
    "\n",
    "def jd_to_daymonthyear(x, pos):\n",
    "    '''Format the axis to convert from Julian day to real date.'''\n",
    "    time = Time(x, format='jd')\n",
    "    time.format = 'iso'\n",
    "    time.out_subfmt = 'date'\n",
    "    return time\n",
    "\n",
    "def compute_ratios(hard_flux, hard_flux_low, hard_flux_high, soft_flux, soft_flux_low, soft_flux_high):\n",
    "    \"\"\"Compute hardness ratios given fluxes in two energy bands.\"\"\"\n",
    "    ratio = hard_flux / soft_flux\n",
    "    soft_err_low = soft_flux - soft_flux_low\n",
    "    soft_err_high = soft_flux_high - soft_flux\n",
    "    hard_err_low = hard_flux - hard_flux_low\n",
    "    hard_err_high = hard_flux_high - hard_flux\n",
    "    ratio_err_low = ((hard_err_low / soft_flux)**2 + (hard_flux * soft_err_low / soft_flux**2)**2)**(1 / 2)\n",
    "    ratio_err_high = ((hard_err_high / soft_flux)**2 + (hard_flux * soft_err_high / soft_flux**2)**2)**(1 / 2)\n",
    "    return ratio, ratio_err_low, ratio_err_high\n",
    "\n",
    "\n",
    "def create_color_array(data_length, cmap='hsv'):\n",
    "    \"\"\"Create an array of colors given the length of a dataset. Useful for plots where a unique color is needed for each dataset.\n",
    "\n",
    "    The returned colors come from the input map (jet by default).\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    data_length : The length of your data for the color array creation.\n",
    "\n",
    "    \"\"\"\n",
    "    print(\"Creating color array for %i datasets\" % data_length)\n",
    "    x = np.arange(data_length)\n",
    "    ys = [i + x + (i * x)**2 for i in range(data_length)]\n",
    "    setmap = plt.get_cmap(name=cmap)\n",
    "\n",
    "    colors = setmap(np.linspace(0, 1, len(ys)))\n",
    "    return colors\n",
    "\n",
    "\n",
    "def get_markers_array(data_length):\n",
    "    \"\"\"Get an array of markers given the length of a dataset. Useful for plots where a unique marker is needed for each dataset.\n",
    "\n",
    "    There are 17 different markers and after that they are repeated.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    data_length : The length of your data for the marker array creation.\n",
    "\n",
    "    \"\"\"\n",
    "    m = ['o', '1', '^', \"_\", \"s\", 'v', 'p', 'P',  'd', '*', 'h', '+', 'X', 'D', '8' , '>', \n",
    "         '<', 'x', '.', (10, 1, 20), (4, 1, 30), (20, 2, 50), '$u$']\n",
    "\n",
    "    while data_length > len(m):\n",
    "        m.extend(m)\n",
    "\n",
    "    return m\n",
    "\n",
    "def draw_arrows(x, y, colors):\n",
    "    for i in np.arange(1, len(x)):\n",
    "        plt.annotate(\"\", xy=(x[i-1],y[i-1]), xytext=(x[i], y[i]),\n",
    "        arrowprops=dict(arrowstyle=\"<-\", shrinkA=10, shrinkB=10, color=colors[i-1]))\n",
    "def fit_diskbb(fluxes, temperatures, temperatures_errlow, temperatures_errhigh):\n",
    "    popt, pconv=curve_fit(diskLvsT, temperatures, fluxes,  \n",
    "                          sigma=(temperatures_errlow + temperatures_errhigh)/2, \n",
    "                          p0=[10**-13,4])\n",
    "    a, b = popt\n",
    "    a_err, b_err = np.sqrt(np.diag(pconv))\n",
    "    return a, b, a_err, b_err\n",
    " \n",
    "    return\n",
    "\n",
    "def diskLvsT(x, a, b):\n",
    "            return a * x**b\n",
    "def radius_tomass(r_in):\n",
    "    return r_in * (c.to(\"km/s\")) ** 2 / 2 / G.to(\"km**3/kg/s**2\") / M_sun\n",
    "def disknorm_tomass(norm, distance, angle=60): \n",
    "    r_in = disknorm_tosize(norm, distance, angle)\n",
    "    return radius_tomass(r_in)\n",
    "def disknorm_tosize(norm, distance, angle=60):\n",
    "    angle_rad = 60/360*2*pi\n",
    "    #mega parsecs to parsecs\n",
    "    distance = distance * 10**3 \n",
    "    r_in = np.sqrt(norm/cos(angle_rad)) * (distance / (10)) * u.km\n",
    "    return r_in\n",
    "def plotdisk(data, ax, param_1=\"Tin\", param_2=\"flux\"):\n",
    "    if len(np.atleast_1d(data))>1:\n",
    "        colors = create_color_array(len(data[\"epoch\"]), \"jet\")\n",
    "        markers = get_markers_array(len(data[\"epoch\"]))\n",
    "    else:\n",
    "        colors = [\"cyan\"]\n",
    "        markers = ['x']\n",
    "    ax.set_prop_cycle(cycler('color', colors))\n",
    "    param_1err_low, param_1err_high, param_1lolimits, param_1uplimits = bounds_to_errors(data[\"%s\" %param_1], \n",
    "                                                                                         data[\"%slow\" %param_1], \n",
    "                                                                                         data[\"%supp\" %param_1])\n",
    "    param_2err_low, param_2err_high, param_2lolimits, param_2uplimits = bounds_to_errors(data[\"%s\" %param_2], \n",
    "                                                                                         data[\"%slow\" %param_2], \n",
    "                                                                                         data[\"%supp\" %param_2])\n",
    "    for index in np.arange(0, len(data[\"epoch\"])):\n",
    "        if data[\"xmm_obsid\"][index]!=\"\":\n",
    "            label=data[\"xmm_obsid\"][index]\n",
    "        else:\n",
    "            label=data[\"chandra\"][index]\n",
    "\n",
    "        ax.errorbar(data[\"%s\" %param_1][index], data[\"%s\" %param_2][index] , \n",
    "                             xerr=[[param_1err_low[index]], [param_1err_high[index]]], \n",
    "                             yerr=[[param_2err_low[index]], [param_2err_high[index]]], label=label, \n",
    "                             marker=\"$ f $\", xlolims=param_1lolimits[index], xuplims=param_1uplimits[index], \n",
    "                             uplims=param_2uplimits[index], lolims=param_2lolimits[index], markersize=10)\n",
    "def eddington_limit(M):\n",
    "    return 1.26 * M * 10**38 / 10**39\n",
    "def bolometric_l(M, m_dot):\n",
    "    return eddington_limit(M) * (1 + 3/5 * np.log(m_dot))\n",
    "def t_disk_max(M, m_dot):\n",
    "    return 1.6 * (M)**(-1/4) * (1 - 0.2 * m_dot**(-1/3))\n",
    "def t_spherization_max(M, m_dot):\n",
    "    return 1.5 * (M)**(-1/4) * m_dot**(-1/2) * (1 + 0.3 * m_dot**(-3/4))\n",
    "def t_photosphere_max(M, m_dot, beta=1, chi=1, epsilon_wind=1/2):\n",
    "    return 0.8 * (beta * chi / epsilon_wind)**1/2 * M**(-1/4) * m_dot**(-3/4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readbroadbandfile(file=\"broadband_fitting_plot.config\"):\n",
    "    broadband_file = \"/home/agurpide/x_ray_data/%s\" %file\n",
    "    plot_config = np.genfromtxt(broadband_file, delimiter=\"\\t\\t\", dtype=(\"U13\", \"U17\", \"U18\", float), names=True)\n",
    "    print(plot_config.dtype)\n",
    "    return plot_config"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sources_tolatex():\n",
    "    plot_config  = readbroadbandfile()\n",
    "    plot_config.sort(order=\"distance\")\n",
    "    [print(\"%s & %.2f \\\\\\\\\" %(data[\"source_name\"], data[\"distance\"])) for data in plot_config]\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[('source_dir', '<U13'), ('model_dir', '<U17'), ('source_name', '<U18'), ('distance', '<f8')]\n",
      "NGC 300 ULX1 (NS) & 2.08 \\\\\n",
      "NGC 55 ULX1 & 2.11 \\\\\n",
      "HoII X-1 & 3.27 \\\\\n",
      "IC342 X-1 & 3.39 \\\\\n",
      "M82 X-1 & 3.61 \\\\\n",
      "NGC 7793 P13 (NS) & 3.63 \\\\\n",
      "M81 X-6 & 3.77 \\\\\n",
      "HoIX X-1 & 3.77 \\\\\n",
      "Circinus ULX5 & 4.20 \\\\\n",
      "NGC 1313 X-1 & 4.25 \\\\\n",
      "NGC 1313 X-2 (NS) & 4.25 \\\\\n",
      "NGC 5204 X-1 & 4.59 \\\\\n",
      "M83 ULX1 & 4.66 \\\\\n",
      "NGC 5408 X-1 & 4.80 \\\\\n",
      "NGC 6946 X-1 & 5.52 \\\\\n",
      "M51 ULX-7 (NS) & 7.60 \\\\\n",
      "M51 ULX-8 (NS?) & 7.60 \\\\\n"
     ]
    }
   ],
   "source": [
    "sources_tolatex()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
